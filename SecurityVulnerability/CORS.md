![cors](https://github.com/DuHyeon2/DailyStudy/assets/83499405/7432e424-d8e4-460c-bef6-ba2faacd37dc)


# 잘못 구성된 Access-Control-Allow-Origin 헤더(CORS)
- Cross Origin Resource Sharing의 약어로 **교차출처 리소스 공유** 이다.
- 동일 출처 정책 때문에 발생하는 에러로 서로 다른 도메인간 자원 공유를 하는 것을 의미.

## 1. 원인
- 허용되지 않은 도메인에서 온 리소스가 로드될 때 발생한다.

## 2. 해결방안
- CORS 필터는 생성하여 헤더에 추가

## 3. web.xml 설정
```
<filter>
    <filter-name>cors</filter-name>
    <filter-class>{CORSFilter를 만든 경로}.CORSFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>cors</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```
- web.xml에 filter로 등록하면 헤더에 설정된다.
- 처음엔 SecurityConfig에 CORS를 설정하는게 있는데 그러면 Security가 Filter를 다 돌고 SecurityConfig의 설정을 입혀서 처음 시작 페이지의 헤더에는 추가가 되지 않았다.
- 그래서 filter에 걸어주었더니 된다.
- filter-name은 하고싶은대로 해도 된다.

## 4. CORSFilter Spring Security 설정
```
@Component
public class CORSFilter implements Filter{

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {
		// TODO Auto-generated method stub
				HttpServletResponse response = (HttpServletResponse) res;
	//		HttpServletRequest request = (HttpServletRequest) req;

        response.setHeader("Access-Control-Allow-Methods", "POST, GET");
        response.setHeader("Access-Control-Max-Age", "3600");
        response.setHeader("Access-Control-Allow-Headers", "x-requested-with");
        response.setHeader("Access-Control-Allow-Origin", "http://111.222.333.444");

        chain.doFilter(req, res);
	}

	@Override
	public void destroy() {
		// TODO Auto-generated method stub
	}

}
```
- 위의 "Access-Control-Allow-Origin" 헤더를 "http://111.222.333.444" 이런식의 아무 도메인으로 변경하면 된다.
- 위의 헤더들도 취약점 고칠 때 도움이 되는 애들이니 저 헤더들도 저런식으로 설정하자.


